查找算法
	顺序查找
	
	二分查找
	
	插值查找
		int mid = left+(right-left)*(value-arr[left])/(arr[right]-arr[left])
	斐波那契查找
		
哈希表
	哈希表结构
		数组+链表
		数组+二叉树

树结构
	数组结构的优缺点
		优点：访问元素的速度快；
		缺点：插入或删除数组元素需要整体移动，效率低下；
	链式存储的优缺点
		优点：插入一个结点只需要将结点插入到指定的位置，不需要整体移动；
		缺点：在进行检索时效率低下；
	树存储结构的分析
		能够提高数据的存储和读取速度；
	删除结点
		如果删除的是叶子节点，则删除该节点；
		如果删除的是非叶子结点，则删除该子树；
	顺序存储二叉树
		将二叉树的结点信息保存在数组中；
		遍历数组是仍然已前序、中序和后续的遍历顺序输出结点；
		顺序存储二叉树的特点
			顺序存储二叉树通常只考虑完全二叉树；
			第n个结点的左子节点为2*n+1；
			第n个结点的右子节点为2*n+2；
			第n个结点的父节点为(n-1)/2；
			注：n从0开始；
	线索二叉树
		左指针是前驱结点，右指针是后继节点；
		代码实现时需要有一个变量保存当前结点的前一个结点；
		注：线索化二叉树是把叶子节点的空指针利用起来；

堆排序
	升序采用大根堆，降序采用小根堆；
	堆排序是要首先构造出一个堆，然后再在这个堆得基础上不断调整堆；

二叉排序树
	左子节点的值比当前的大，右子节点的值比当前的结点小

平衡二叉树
	左旋转
		创建一个新结点，其值等于当前根结点；
		把新结点的左子树设置为当前结点的左子树；
		把新结点的右子树设置为当前结点的右子树的左子树；
		把当前结点的值换成右子结点的值；
		把当前结点的右子树设置为右子树的右子树；
		把当前结点的左子树设置为新结点；
	右旋转
		创建一个新结点，值等于当前结点的右子树；
		新结点的右子树设置为当前结点的右子树；
		新结点的左子树设置为当前结点左子树的右子树；
		当前结点的值替换成左子结点的值；
		当前结点的左子树设置为左子树的左子树；
		当前结点的右子树设置为新结点；
	注：
		当符合右旋转条件时
			若左子树的右子树高度大于它的左子树高度；
			先对当前这个结点的左结点进行左旋转；
			在对当前结点进行右旋转的操作即可；
		当符合左旋转条件时
			若右子树的左子树高度大于它的右子树高度；
			先对当前这个结点的右结点进行右旋转；
			再对当前结点进行左旋转；

多叉树
	B树通过重新组织结点，降低树的高度，并且减少io读写次数来提升效率；
	B树的概念
		B树的阶，结点最多的子结点个数；
		B树的搜索，从根结点开始，对结点内的关键字序列进行二分查找，如果命中则结束，否则继续查找；
	B+树
	 B+树只有到达叶子结点才命中；
	 所有关键字都出现在叶子结点的链表中；
	 不可能在非叶子结点命中，非叶子结点相当于叶子结点的索引；
	 