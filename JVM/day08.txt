1、GC性能指标
	吞吐量
		CPU用于运行用户代码的时间与CPU总消耗时间的比值（吞吐量=运行用户代码时间/(运行用户代码时间+垃圾收集时间)）
		吞吐量优先意味着在单位时间内STW的时间最短；
	暂停时间
		一个时间段内应用程序线程暂停，让GC线程执行的状态；
		优先STW意味着尽可能让单词STW时间最短；

2、经典垃圾回收器
	Serial GC（新生代）
		复制算法、串行回收和STW；
	Serial Old GC（老年代）
		标记-压缩算法、串行回收和STW；
		Client模式下默认是老年代的垃圾回收器；
		Server模式下与新生代的Parallel Scavenge GC配合使用和作为老年代CMS收集器的后背垃圾收集方案；
		指令：-XX:+UseSerialGC表明新生代使用Serial GC，同时老年代使用Serial Old GC；
	Parallel Scavenge GC（新生代）
		复制算法、并行回收和STW；
		Parallel Scavenge收集器的目标则是达到一个可控制的吞吐量，它也被称为吞吐量优先的垃圾收集器；
		指令：-XX:+UseParallelGC 手动指定年轻代使用Parallel并行收集器执行内存回收任务（开启一个另一个也会被开启）；
			  -XX:ParallelGCThreads 设置年轻代并行收集器的线程数；
			  -XX:MaxGCPauseMillis 设置垃圾收集器最大停顿时间；
			  -XX:GCTimeRatio 垃圾收集时间占总时间的比例，用于衡量吞吐量的大小；
			  -XX:+UseAdaptiveSizePolicy 设置Parallel Scavenge收集器具有自适应调节策略（默认开启），年轻代、Eden和Survivor比例、晋升老年代的对象等参数会被自动调节；
	Parallel Old GC（老年代）
		用来代替Serial Old收集器，采用标记-压缩算法，但同样也是基于并行回收和STW机制；
		再程序吞吐量优先的应用场景中，Parallel收集器和Parallel Old收集器的组合，在Server模式下内存回收性能很不错；
		指令：-XX:+UseParallelOldGC 手动指定老年代都是使用并行回收收集器（开启一个另一个也会被开启）；
	ParNew GC（新生代）
		ParNew收集器除了采用并行回收的方式执行内存回收外，两款
		指令：-XX:+UseParNewGC手动指定使用ParNew收集器执行内存回收任务；
			  -XX:ParallelGCThreads 限制线程数量，默认开启和CPU数据相同的线程数；
	CMS GC（老年代）
		标记-清除算法、并发回收和STW；
		CMS回收过程
			初始标记
				程序中所有的工作线程都将会因为STW出现短暂的暂停，这个阶段的主要任务仅仅是标记出GC Roots能直接关联到对象；
			并发标记
				从GC Roots的直接关联对象开始遍历整个对象图的过程，
			重新标记
				为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录；
			并发清除
				清理删除掉标记阶段判断的已经死亡的对象（不需要移动对象），释放内存空间；
		优缺点
			优点
				并发收集、低延迟；
			缺点
				会产生内存碎片，如果遇到大对象，可能会触发FULL GC；
				CMS收集器的吞吐量会降低；
				CMS收集器无法处理浮动垃圾（在并发标记的阶段新产生的垃圾）；
	G1 GC（整个堆）
		G1垃圾收集器把堆内存分割为很短不相关的区域，分别表示为Eden、S0、S1、老年代等，在后台维护一个优先列表，每次根据允许的收集时间，优先回收值最大的Region；
		G1的特点
			并行与并发
				并行性
					G1在回收期间，可以有多个线程同时工作，有效利用多核计算能力，此时用户线程STW；
				并发性
					G1拥有与应用程序交替执行的能力，部分工作可以和应用程序同时执行，因此，一般来说，不会在整个回收阶段发生完全阻塞应用程序的情况；
			分代收集
				G1依然属于分代型垃圾收集器，它会区分年轻代和老年代，年轻代依然有Eden区和Survivor区，但是从对结构上来看它不要求整个Eden区、年轻代或者老年代都是连续的，也不坚持固定大小和固定数量；
				将堆空间分为若干个区域（Region），这些区域中包含了逻辑上的年轻代和老年代；
				和之前的各类回收器不同，它同时兼顾年轻代和老年代；
				Region的使用
					所有Region的大小是相同的，且在JVM生命周期里不会改变；
					一个Region只可能属于一个角色（E、S、O、H）G1收集器增加了一个新的内存区域Humongous区域，用于存放大对象，如果对象的带线啊哦超过1.5个region就存放到H
						短期存在的大对象对垃圾收集器造成负面影响，所以存放在H区，如果一个H区装不下一个大对象，那G1就会寻找连续的H区来存储，G1的大多数行为都把H区作为老年代的一部分来看待；
			空间整合
				G1将内存划分为一个个Region，内存的回收是以region作为基本单位的，Region之间是复制算法，但整体上实际可以看作是标记-压缩算法，两种算法都可以避免内存碎片，这种特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前出发下一次GC，尤其是当Java堆非常大时，G1的又是更加明显；
			可预测的停顿时间模型
				G1收集器可以在一个指定的长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不超过N毫秒
					由于使用了划分区域，所以每次回收可以选取部分区域进行内存回收；
					G1跟踪各个Region里面的垃圾堆积的价值大小，在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值（回收所获得的空间大小以及回收所需时间的经验值）最大的Region，保证了G1收集器在有限时间内可以获取尽可能高的收集效率；
		G1收集器主要包括如下三个环节
			年轻代GC
				并行的独占式收集器，在年轻代回收期，G1 GC暂停所有应用线程，启动多线曾执行年起古代执行年轻代回收，然后从年轻代区间移动存活对象到Survivor区或者老年区间，也有可能是两个区间都会涉及；		
				年轻代回收过程
					扫描根
						根是指static变量指向的对象，正在执行的方法条用链条上的局部变量等，根引用连同RSet记录的外部引用作为扫描存活对象的入口；
					更新RSet
						处理dirty card queue（将引用程序的引用赋值语句中的对象保存下来），年轻代回收时G1会对DCQ中所有的card进行处理，已更新RSet，保证RSet实时准确的反映引用关系；
						此阶段完成后，RSet可以准确的反应老年代所在的内存分段中对象的引用；
					处理RSet
						识别被老年代对象执行的Eden中的对象，这些被指向的Eden中的对象被认为是存活的对象；
					复制对象
						对象树会被遍历，Eden区内存中存活的对象会被复制到Survivor区中空的内存分段，Survivor区内存中存活的对象如果年龄未达阈值，年龄就会加1，达到阈值的则会被复制到Old区中空的内存分段；
						如果Survivor区空间不够，Eden空间的部分数据会直接晋升到老年代空间；
					处理引用
						处理Soft，Weak，Phantom，Final，JNI Weak等引用；复制过程可以达到内存整理的效果，减少碎片；
			老年代并发标记过程
				当堆内存使用达到一定值（默认45%时），开始老年代并发标记过程；
				标记完成马上开始混合回收过程，对于一个混合回收期，G1 GC从老年区间移动存活对象到空闲区间，这些空闲区间也就成为老年代的一部分，G1的老年代回收器不需要整个老年代被回收，一次只需要扫描/回收一小部分老年代的Region；
				并发标记过程
					初始标记阶段
						标记从根节点直接可达的对象。这个阶段是STW的，并且会触发一次年轻代GC；
					根区域扫描
						G1 GC扫描Survivor区直接可达的老年代区域对象，并标记被引用的对象，这一过程必须在young GC之前完成；
					并发标记
						在整个堆中并发标记（和应用程序并发执行），此过程可能被young GC中断，并发标记阶段，若发现区域对象中的所有对象都是垃圾，那这个区域会被立即回收，同时并发标记解读那中会计算每个区域的对象活性（取域中存活对象的比例）；
					再次标记
						由于应用程序继续执行，需要修正上一次的标记结果，是STW，实际上这一阶段并不会实际上去做垃圾的收集；
					独占清理
						计算各个区域的存活对象和GC回收比例，并进行排序，识别可以混合回收的区域，
					并发清理阶段
						识别并清理完全空闲的区域；
			混合回收
				老年代Regionhi和年轻代一起被回收；
				混合回收过程
					并发标记结束以后，老年代中百分之百为垃圾的内存分段被回收了，部分为垃圾的内存分段被计算出来，默认情况下，这些老年代的内存分段会分8次（可以通过-XX:G1MixedGCCountTarget设置）被回收；
					混合回收的收集包括八分之一的老年代内存分段，Eden区内存分段，Survivor区内存分段；
					G1会优先回收垃圾多的内存分段，垃圾占内存比例越高，越会被先回收，并且有一个阈值会决定内存分段是否被回收（-XX:G1MixedGCLiveThresholdPercent，默认65%），当垃圾占内存分段比例达到65%才会被回收；
					混合回收并不一定要进行8次，有一个阈值-XX:G1HeapWastePercent（默认是10%），意思是允许整个堆内存有10%的空间被浪费，当发现可以回收的垃圾占堆内存的比例不超过10%，则不进行垃圾回收；
			注：如果需要，Full GC还是继续存在的；
		记忆集
			每一个Region都有一个对应的Remembered Set；
			每次引用类型数据写操作时，都会产生一个写屏障暂时中断操作；
			然后检查将要写入的引用指向的对象是否和该Reference类型数据在不同的Region；
			如果不同，通过CardTable把相关引用信息记录到引用指向对象的所在Region对应的Remember Set中；
			当进行垃圾收集时，在GC根节点的枚举范围加入Remember Set，就可以保证不进行全局扫描，也不会有遗漏；
		参数设置
			-XX:+UseG1GC	启用G1收集器执行内存回收任务；
			-XX:G1HeapRegionSize	设置每个Region的大小，值是2的幂，范围是1MB-32MB，目标是根据最小的Java堆大小划分出约2048个区域，默认大小是堆内存的1/2000；
			-XX:MaxGCPauseMillis	设置期望达到的最大GC停顿时间，默认是200ms；
			-XX:ParallelGCThead		设置STW工作线程数的值，最多设置为8；
			-XX:ConcGCThreads		设置并发标记的线程数，将n设置为并行垃圾回收线程数的1/4左右；
			-XX:InitiatingHeapOccupancyPercent	设置触发并发GC周期的Java堆占用有、率阈值，超过此值就会触发GC，默认是45%；
3、GC日志
	内存分配与垃圾回收的参数列表
		-XX:+PrintGC			输出GC日志，类似-verbose:gc
		-XX:+PrintGCDetails		输出GC详细日志
		-XX:+PrintGCTimeStamps	输出GC的时间戳
		-XX:+PrintGCDateStamps	输出GC的时间戳（以日期的形式，2021-06-15T10:43:21+0800）
		-XX:+PrintHeapAtGC		在进行GC的前后打印出堆的信息
		-Xloggc:../logs/gc.log	日志文件的输出路径
	日志数据分析
		Allocation Failure
			表明本次引起GC的原因是因为在年轻代中没有足够的空间能够存储新的数据了；
		[PSYoungGen: 5986K->696K(8704K)] 5986K->704K(9216K)
			中括号内：GC回收前年轻代的大小，回收后的大小，（年轻代总大小）；
			括号外：GC回收前年轻代和老年代大小，回收后大小，（年前带和老年代总大小）；
		user代表用户回收好事，sys内核态回收耗时，rea实际耗时；
		