1、本地方法栈
	本地方法接口
		一个Native Method就是一个Java调用非Java代码的接口，标识符native可以与所有其它的Java标识符连用，abstract除外；
	Java虚拟机栈用于管理Java方法的调用，而本地方法栈适用于管理本地方法的调用；
	本地方法栈也是线程私有的；
	允许被实现成固定或者冬天扩展的内存大小（在内存溢出方法面是相同的）
	本地方法使用C语言实现；
	本地方法栈中登记native方法，在执行引擎执行时加载本地方法库；
	当某个线程调用一个本地方法时，它不再受虚拟机限制，拥有和虚拟机相同的权限
		本地方法可以通过本地方法接口来访问虚拟机内部的运行时数据区；
		它甚至可以直接使用本地处理器中的寄存器；
		直接从本地内存的队中分配任意数量的内存；

2、堆
	堆的核心概述
		JVM实例只存在一个堆内存，在JVM启动时即创建一个Java堆区；
		堆可以实物理上不连续的内存空间，逻辑上是连续的；
		所有线程共享Java堆，在这里还可以划分线程私有的缓冲区；
		所有的对象实例以及数组都应该在运行时分配到堆上；
		数组和对象几乎不会存储在栈上，因为栈帧中保存引用，这个引用指向对象或数组在堆中的位置；
		方法结束后，队中的对象不会马上被移除，只有在垃圾收集的时候才会被移除；
	内存细分
		Java8之后堆内存在逻辑上分为三部分：新生区、养老区和元空间
			年轻代与老年代
				JVM中对象可以被划分为两类
					一类是生命周期较短的瞬时对象，这类对象的创建和消亡都非常迅速；
					一类是生命周期较长的对象，在某些极端情况下还能与JVM的生命周期保持一致；
				年轻代可以划分为Eden空间、Survivor0空间和Survivor1空间（有时也叫from区、to区）；
				配置新生代与老年代
					-XX:NewRatio=2，表示新生代占1，老年代占2，新生代占整个堆1/3（默认NewRatio=2）；
					-XX:SurvivorRatio=8，设置新生代中Eden区与Survivor区的比例；
					-Xmn，设置新生代的空间的大小（一般不设置）；
					默认情况下JVM会利用自适应内存分配策略分配Eden区和S0区和S1区的配比；
				几乎所有的对象都是在Eden区被new出来的，绝大部分Java对象的销毁都在新生代进行；
		Java堆内存的大小包括新生区和养老区之和；
	设置堆内存大小与OOM
		设置堆空间大小的指令（不包括元空间）
			-Xms（后面填写的数字规则和-Xss一样）
				表示堆区的起始内存，等价于-XX:InitialHeapSize；
			-Xmx（后面填写的数字规则和-Xss一样）
				表示堆区的最大内存，等价于-XX:MaxHeapSize；
		一旦堆区中的内存大小超过了-Xmx指定的最大内存时，将会抛出OutOfMemoryError异常；
		默认情况
			初始内存是电脑内存的/64，最大内存是电脑内存的/4；
		查看设置的参数
			方式一
				利用jps获取相应的进程id；
				使用jstat -gc 进程id，获取对应进程的内存使用情况；
			方式二
				JVM指令：-XX-XX:PrintGCDetails,查看GC日志
		产生OOM错误时，程序会直接退出；
	对象分配过程
		一般过程
			new的对象先放伊甸园区，此区大小有限制；
			当伊甸园区的空间填满时，程序有需要创建对象，JVM的垃圾回收器将对伊甸园区进行垃圾回收（Minor GC，幸存者区也会进行垃圾回收），将伊甸园区中不再被其他对象所引用的对象进行销毁，再加载新的对象放到伊甸园区；
			然后将伊甸园中的剩余对象移动到S0区（每次移动时年龄计数器+1）；
			如果再次触发垃圾回收，此时上次放进S0区的对象如果没有被收回，再接着去S1区（年龄计数器+1）；
			如果再次出发垃圾回收，此时会重新放入S0区，接着再去S1区；
			如果对象的年龄计数器达到阈值（默认是15次），该对象会进入养老区；
				-XX:MaxTenuringThreshold=N进行设置阈值的大小；
			注：当伊甸园区满的时候会触发Minor GC，会对伊甸园区和幸存者区都执行垃圾回收操作；
				垃圾回收会频繁在新生区收集，很少在养老区收集，几乎不在元空间收集；
		特殊情况
			新对象申请分配内存，如果伊甸园区放不下就会触发Minor GC，放得下则分配内存；
			如果伊甸园区还是放不下则会直接放入养老区，放得下则分配内存；
			如果养老区也放不下则会触发养老区的Major GC（伊甸园区进行垃圾回收过程中如果幸存者区放不下或对象年龄计数器超过阈值则放入养老区），放得下则分配内存；
			养老区垃圾回收完后，如果还是放不下则OOM，如果放得下则分配内存；
		Minor GC、Major GC和Full GC
			JVM在GC时并不是每次都对新生代、老年代和方法区一起回收，大部分回收都是指新生代；
			HotSpot JVM里GC按照回收区域又划分为部分手机，整堆收集
				部分收集（不是完整手机整个Java堆）
					新生代收集：只是新生代的垃圾收集
					老年代收集：只是老年代的垃圾收集
						只有CMS GC会有单独手机老年代的行为；
						注：很多时候Major GC和Full GC混淆使用，需要具体分辨是老年代回收还是整堆回收；
					混合收集：收集整个新生代以及部分老年代的垃圾收集（G1 GC）
				整堆收集（收集整个Java堆和方法区的垃圾回收）
			Minor GC触发机制
				当年轻代空间不足时，就会触发Minor GC，这里的年轻代满指的是Eden代满，Survivor满不会引发GC（每次Minor GC会清理年轻代内存）；
				Minor GC执行很频繁；
				Minor GC会引发STW，暂定其他用户的线程，等垃圾回收结束，用户线程才恢复；
			Major GC触发机制
				出现Major GC，经常会伴随至少一次的Minor GC（并非绝对）
					老年代空间不足时会先触发Minor GC，如果之后的空间还不足，则会触发Major GC；
				Major GC后如果内存还不足就会报OOM错误；
				Major GC速度一般比Minor GC慢10倍以上，STW时间也更长；
			Full GC触发机制
				调用System.gc()时,系统建议执行Full GC,但是不必然执行;
				老年代空间不足;
				方法区空间不足;
				通过Minor GC后进入老年代的平均带线啊哦大于老年代的可用内存;
				由Eden区和From区向To区复制时,对象的大小大于To区可用内存,则把该对象转移到老年代,且老年代的可用内存小于该对象大小; 
		内存分配策略
			优先分配到Eden区;
			大对象直接分配到老年代;
			长期存活的对象分配到老年代;
			动态对象年龄判断
				如果S0/S1区中相同年龄的所有对象大小的总和大于S0/S1区的一半,年龄大于或等于该年龄的对象可以直接进入老年代,无需等到MaxTenuringThreshold中要求的年龄;
				空间分配担保
					-XX:HandlePromotionFailure
		对象分配过程TLAB
			从内存模型的角度,对Eden区继续进行划分,JVM为每个线程分配一个私有缓存区域,包含在Eden空间内;
			多线程同时分配内存时,使用TLAB可以避免一系列的非线程安全问题,同时还能够提升内存配置的吞吐量;
			再给对象分配内存的过程中,首先考虑TLAB;
			JVM中关于TLAB的参数设置
				默认情况下,TLAB空间的内存非常小,可以通过JVM参数改变TLAB空间在Eden区的占比
					-XX:TLABWasteTargetPercent
				是否启用TLAB
					-XX:UseTLAB
			一旦对象在TLAB空间分配内存失败时,JVM就会尝试通过使用加锁机制确保数组操作的原子性;
	堆空间常用的JVM参数
		-XX:+PrintFlagsInitial	查看所有的参数的默认初始值
		-XX:+PrintFlagsFinal	查看所有的参数的最终值
		-Xms	初始化堆空间内存(默认为物理内存的1/64)
		-Xmx	最大堆空间内存
		-Xmn	设置新生代的大小
		-XX:NewRatio	配置新生代与老年代在对结构的占比
		-XX:SurvivorRatio	设置新生代中Eden和S0/S1空间的比例
		-XX:MaxTenuringThreshold	设置新生代垃圾的最大年龄
		-XX:+PrintGCDetails		输出详细的GC处理日志信息
		-XX:+PrintGC	打印gc简要信息
		-XX:HandlePromotionFailure	是否设置空间分配担保
	逃逸分析
		逃逸分析的基本行为是分析对象动态作用域
			当一个对象在方法中被定义后,它被外部方法所引用,则认为发生逃逸;
			当一个方法在方法中被定义后,对象只在方法内部使用,则认为没有发生逃逸;
		没有发生逃逸的对象则可以分配到栈上,随着方法的执行结束,栈空间就被移除;
		方法内new的对象实体是否有可能在方法外面被调用,如果会被调用则发生逃逸,否则不发生逃逸;
		逃逸分析结论
			开发中能使用局部变量的,就不要使用在方法外定义;
		使用逃逸分析,编译器进行代码优化
			栈上分配
				JIT编译器在编译期间根据逃逸分析的结果,发现如果一个对象并没有逃逸出方法,就可能被优化成栈上分配;
				逃逸情况
					给成员变量赋值;
					方法返回值;
					实例引用传递;
			同步省略(也称为锁消除)
				在动态编译同步块时,JIT编译器会借助逃逸分析来判断同步块所使用的锁对象是否只能够被一个线程访问而没有被发布到其他线程,如果没有JIT编译器则会在编译这个代码块的时候取消这部分代码的同步;
			分离对象或标量替换
				有的对象可能不需要作为一个连续的内存结构也可以被访问到,那么对象的部分可以不存储在内存,而是存储在CPU寄存器中;
				标量是指一个无法再分解成更小的数据的数据,Java中原始数据类型就是标量;
				那些可以分解的数据叫做聚合量,Java中对象就是聚合量;
				标量替换
					在JIT阶段,如果经过逃逸分析一个对象不会被外界访问的话,经过JIT优化,就会把这个对象拆解成若干个其中包含的若干个成员变量来替换;