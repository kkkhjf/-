1、JVM整体结构
	Java编译器的架构模型
		基于栈式架构
			特点
				设计和实现更简单，适用于资源受限的系统；
				避开了寄存器的分配难题；使用零地址指令方式分配；
				指令流中的大部分是零地址指令，其执行过程依赖于操作栈；
				不需要硬件支持，可移植性更好；
		基于寄存器架构模型
			特点
				典型应用是x86的二进制指令集；
				指令集架构则完全依赖硬件，可移植性差；
				性能更优秀，效率更高；
				花费更少的指令去完成一项操作；
				一般情况，基于寄存器架构的指令集往往都是以一地址指令、二地址指令和三地址指令为主，而基于栈式架构的指令集以零地址为主；
	JVM的生命周期
		虚拟机的启动
			Java虚拟机的启动是通过引导类加载器（bootstrap class loader）创建一个初始类（initial class）来完成，这个类由虚拟机的具体实现指定；
		虚拟机的执行
			执行一个所谓的Java程序的时候，真正在执行的是一个叫Java虚拟机的进程；
		虚拟机的退出
			程序正常结束或程序执行过程中遇到错误和异常；
			某线程调用Runtime类或System类的exit方法，或Runtime类的halt方法，并且Java安全管理器也允许这次的exit或halt操作；
			
	类加载器子系统
		从文件系统或网络中加载Class文件，class文件在在文件开头有特定的标时；
		ClassLoader只负责class文件的加载，文件的运行则是由执行引擎决定；
		加载的类信息存放于一块方法区的内存空间，方法区中还会存放运行时常量池信息；
		
		类的加载过程
			加载
				通过一个类的全限定名获取定义此类的二进制字节流；
				将这个字节流所代表的静态存储结构转换为方法区的运行时数据结构；
				在内存中生成一个代表这个类的java.lang.Class对象,作为方法区这个类的各种数据的访问入口;
			连接
				验证
					确保Class文件的字节流中包含的信息是符合当前虚拟机要求;
					主要包括四种验证,文件格式验证,元数据验证,字节码验证和符号引用验证;
				准备
					为变量分配内存并且设置该变量的默认初始值;
					这里不包含用final修饰的static,final在编译的时候就会分配了,准备阶段会显式初始化;
					这里不会为实例变量分配初始化,类变量会分配在方法区中,实例变量会随着对象一起分配到Java堆中;
				解析
					将常量池中的符号引用转换为直接引用;
					解析操作往往会伴随着JVM在执行完初始化后再执行;
					符号引用就是一组符号来描述所引用目标,直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄;
					解析动作只要是针对类或接口、字段、类方法、接口方法、方法类型等;
			初始化
				初始化阶段就是执行类构造器方法<clinit>()的过程(此方法不需要定义，是javac编译器自动手机类中的所有类变量的赋值动作和静态代码块中的语句合并而来);
				构造器方法中指令按语句在源文件中出现的顺序执行；
				<clinit>()不同于类的构造器；(构造器是虚拟机视角下的<init>())
				若该类存在父类，JVM会先调用父类的<clinit>()；
				虚拟机必须保证一个类的<clinit>()方法在多线程下被同步加锁（某一个线程在加载一个类时，其他线程不能加载这个类）；
				
				注：若赋值代码中没有static关键字的修饰，则不会创建<clinit>()方法；
		
		类加载器的分类 
			引导类加载器（Java核心类库使用引导类加载器加载）
				BootsreapClassLoader引导类加载器
					加载Java的核心类；
					Java代码中无法获取到引导类加载器；
					不继承于ClassLoader，没有父加载器；
					加载扩展类和应用程序类加载器，并指定为他们的父类加载器；
				自定义加载器
					ExtClassLoader扩展类加载器
						派生于ClassLoader类；
						父类为启动类加载器；
						用户创建的JAR放在JDK安装目录的jre/lib/ext目录下，也会自动由扩展类加载器加载；
					AppClassLoader系统类加载器
						派生于ClassLoader类；
						父类加载器为扩展类加载器；
						负责加载环境变量classpath或系统属性java.class.path指定路径下的类库；
					用户自定义加载器（默认使用系统类加载器加载）
				注：这四者是包含关系，不是上下层关系也不是继承关系；
			需要自定义加载器的情况
				隔离加载类
				修改类加载的方式
				扩展加载源
				防止源码泄露
			用户自定义类加载器实现步骤
				继承java.lang.ClassLoader类的方式，实现的类加载器；
				在编写自定义类加载器时，如果有太过于复杂的需求，可以直接继承URLClassLoader类，这样可以避免自己去编写findClass()方法及其获取字节码流的方式，使自定义类加载器更加简洁；
			ClassLoader类
				ClassLoader类是一个抽象类，其后所有的类加载器都继承自ClassLoader
				获取ClassLoader的途径
					获取当前类的ClassLoader
						clazz.getClassLoader();
					获取当前线程上下文的ClassLoader
						Thread.currentThread().getContextClassLoader();
					获取系统的ClassLoader
						ClassLoader.getSystemClassLoader();
					获取调用者的ClassLoader
						DriverManage.getCallerClassLoader();
			双亲委派机制
				Java虚拟机对class文件采用的是按需加载（当需要使用这个类时才会将它加载到内存生成class对象）的方式，
					Java虚拟机采用的是双亲委派模式，即把请求交由父类处理，他是一种任务委派模式；
				工作原理
					如果一个类加载器收到了类加载，它会把这个请求交给父类的加载器去执行；
					如果父类加载器还存在其他父类加载器，则会进一步向上递归请求，最终达到顶层的启动类加载器；
					如果父类加载器可以完成类加载任务，就成功返回，如果父类加载器无法完成加载任务，自家在其才会尝试自己去加载；
					注：接口是由引导类加载器加载，但是接口里的实现类是由系统类加载器加载；
				优势
					避免类的重复加载；
					保护程序安全，防止核心API被随意篡改；
			沙箱安全机制
				自定义String类，但是在加载自定义String类时会先使用引导类加载器加载，引导类加载器在加载过程中，会先加载jdk自带的文件(rt.jar包中java\lang\String.ClassLoader)，这样可以保证对java核心源代码的保护；
			类加载器子系统信息汇总
				JVM中判断两个class对象是否为同一个类
					类的完整类名必须一致，包括包名；
					加载这个类的ClassLoader实例对象必须相同；
				JVM需要知道一个类型是由启动类加载器还是用户类加载器加载，如果一个类型是由用户类加载器加载，那么JVM会将这个类加载器的一个引用作为类型信息的一部分保存在方法区中，当解析一个类型到另一个类型的引用的时候，JVm需要保证这两个类型的类加载器是一样的；
				Java程序对类的使用方式分为主动使用和被动使用
					主动使用
						创建类的实例；
						访问某个类或接口的静态变量，或者对该静态变量赋值；
						调用类的静态方法；
						反射；
						初始化一个类的子类；
						Java虚拟机启动时被标明为启动类的类；
						JDK7开始提供的动态语言的支持；
					被动使用
						除了以上情况就是被动使用；
					主动使用和被动使用的区别就是主动使用会导致类的初始化，被动则不会；
			