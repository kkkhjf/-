1、方法区
	堆、栈和方法区间的交互关系
		Person person = new Person();
	   方法区   Java栈    Java堆
	方法区理解
		方法看作是一块独立于Java堆的内存空间；
		方法区和Java堆一样是各个线程共享的内存区域；
		方法区在JVM启动时创建，并且它的实际物理内存空间中和Java堆区一样都可以是不连续；
		方法区的大小跟堆空间一样可以选择固定或者可扩展；
		方法区的大小决定了系统可以保存多少个类，如果系统定义了太多的类，导致方法区移除，虚拟机同样会抛出内存溢出的错误；
		关闭JVM就会释放这个区域的内存；
	设置方法区大小与OOM
		设置方法区大小的参数
			-XX:MetaspaceSize		指定方法区的初始大小
			-XX:MaxMetaspaceSize	指定方法区的最大值
		方法区初始值是21M，一旦内存不够FULL GC将会被触发并卸载没用的类（即这些类对性的类加载器不再存活），如果内存还是不够，在不超过最大值的情况下会适当提高方法区大小；
	方法区的内部结构
		方法区存放已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存
			类型信息
				堆每个加载的类型（类class、接口interface、枚举enum、注解annotation），JVM必须在方法区中存储以下类型信息
					这个类型的完整有效名称(全名=包名.类名)；
					这个类型直接父类的完整有效名(对于interface或是java.lang.Object，都没有父类)；
					这个类型的修饰符(public、abstract、final的某个子集)；
					这个类型直接接口的一个有序列表；
			域信息
				JVM必须在方法区中保存类型的所有域相关的信息以及域的声明顺序；
				域的相关信息包括域名称、域类型、域修饰符(public、private、protected、static、final、volatile、transient的某个子类)；
			方法信息
				JVM必须保存所有方法的以下信息。同域信息一样包括声明顺序
					方法名称；
					方法的返回类型(或void)；
					方法参数的数量和类型；
					方法的修饰符(public、private、protected、static、final、volatile、transient的某个子类)；
					方法的字节码(bytecodes)、操作数栈、局部变量表及大小(abstract、native方法除外)；
					异常表(abstract、native方法除外)（try里面的代码）
						每个异常处理的开始位置、结束位置、代码处理在程序计数器中的偏移地址、被捕获的异常类的常量池索引；
			non-final的类变量
				静态变量和类关联在一起，随着类的加载而加载，它们称为类数据在逻辑上的一部分；
				类变量被类的所有实例共享。及时美欧雷士时也可以访问它；
				群居常量(static和final修饰的变量)
					被声明为final的类变量的处理方法则不同，每个全局常量在编译的时候就会被分配；
					如果没有被final修饰则在编译期间不会赋值，会在<clinit>中对静态变量进行赋值操作；
		注：字节码件中会保存方法区中的上述信息；
	运行时常量池
		常量池
			一个有效的字节码文件中除了包含类的版本信息、字段、方法以及接口等描述信息外，还包含一项信息那就是常量池表，包括各种字面量和对类型、域和方法的符号引用；
			一个java源文件中的类、接口，编译后产生一个字节码文件，而java中的字节码需要数据支持，通常这种数据很大以至于不能直接存储到字节码里，换另一种方式，可以存储到常量池中，在动态连接的时候会用到运行时常量池；
			常量池中存储的数据类型包括
				数量值、字符串值、类引用、字段引用和方法引用；
			常量池可以看作是一张表，虚拟机指令根据这张常量池表找到要执行的类名、方法名、参数类型、字面量等类型；
		运行时常量池
			运行时常量池是方法区的一部分，常量池是Class文件的一部分，用于存放编译期生成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中；
			在加载类和接口到虚拟机后，就会创建对应的运行时常量池；
			JVM为每个已加载的类型都维护一个常量池，池中的数据项通过索引来访问；
			运行时常量池包含多种不同的常量，包括编译期就已经明确的数值字面量，也包括运行期解析后才能获得的方法或字段引用；
			运行时常量池所需的内存空间超过了方法区提供的最大值会抛出OOM异常；
		字符串常量池从永久代转移到堆中是为了能够更高效回收字符串常量；
		静态引用对应的对象实体始终存放在堆空间，在7及以后的版本中静态引用的变量名也是存放在堆中；
	方法区的垃圾回收
		方法区的垃圾收集主要受回两部分内容：常量池中废弃的常量和不再使用的类型；
		常量的回收
			方法区内常量池中主要分为两大常量
				字面量
					字面量比较接近Java语言层次的常量概念；
				符号引用
					类和接口的全限定名；
					字段的名称和描述符；
					方法的名称和描述符；
			只要常量池中的常量没有被任何地方引用就可以被回收；
		类的回收
			判断一个类不再使用的条件
				该类所有的实例都已经被回收，也就是Java堆中不存在该类及其任何派生子类的实例；
				该加载类的类加载器已经被回收；
				该类对应的java.lang.Class对象没有任何地方被引用；
			Java虚拟机被允许对满足上述三个条件的无用类进行回收；
			