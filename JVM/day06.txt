1、执行引擎
	将字节码指令解释/编译为对应平台上的本地机器指令；
	执行引擎在执行过程中究竟需要执行什么样的字节码指令完全依赖于PC寄存器；
	每当执行完一项指令操作后，PC寄存器就会更新下一条需要被执行的指令地址；
	在方法执行过程中，执行引擎有可能会通过存储在局部变量表中的对象引用准确定位到存储在Java堆中的对象实例信息，以及通过对象头中的元数据指针定位到目标对象的类型信息；
	所有Java虚拟机的执行引擎输入的是字节码二进制流，处理过程是字节码解析执行的等效过程，输出的是执行结果；
	Java代码编译和执行的过程
		解释器
			当Java虚拟机启动的时候会根据定义的规范堆字节码采取逐行解释的方式执行，将每条字节码文件中的内容翻译为对应平台的本地机器指令执行；
		JIT编译器
			虚拟机将源代码直接编译成和本地机器平台相关的机器语言；
			热点代码及探测方式
				一个被多次调用的方法，或者是一个方法内部循环次数较多的循环体都可以被称之为“热点代码”，因此都可以通过JIT编译器比那一为本地机器指令；
				HotSpot VM采用的是基于计数器的热点探测
					方法调用计数器：统计方法的调用次数；
					汇编计数器：统计循环体执行的循环次数；
				计数器的触发阈值在Client模式下是1500次，在Server模式下是10000次，超过这个阈值就会触发JIT编译；
				使用-XX:CompileThreshold设定阈值的大小；
				超过一定的时间限度，这个方法的调用计数器就会被减少一半，使用-XX:-UseCounterDecay来关闭热度衰减,-XX:CounterHalfLifeTime参数设置半衰周期时间，单位是秒；
			注：JIT编译器在编译完后会把编译的结果放在缓存中；
		HotSpot VM设置程序执行方式
			-Xint：完全采用解释器模式执行程序；
			-Xcomp：完全采用即时编译器模式执行程序；
			-Xmixed：采用解释器+即时编译器混合模式；

2、String Table
	String代表不可变的字符序列（不可变性）
		当对字符串重新赋值时，需要重写指定内存区域赋值，不能使用原有的value进行赋值；
		当对现有字符串进行连接操作时，也需要重新指定内存区域赋值，不能使用原有的value进行赋值；
		当调用String的replace()方法修改指定字符或字符串时，也需要重新制定内存区域赋值，不能使用原有的value进行赋值；
	字符串常量池
		字符串常量池中不会存储相同内容的字符串；
		String Pool是一个固定大小的HashTable，默认大小长度是1009，如果放进String Pool的string非常多，就会造成Hash冲突严重，从而导致链表会很长，而链表长了后会造成调用String.intern时性能大幅下降；
		使用-XX:StringTableSize可设置StringTable的长度；
		jdk8开始，设置StringTable长度的最小值是1009； 
	String的内存分配
		常量池类似一个Java系统级别提供的缓存，8种基本数据类型的常量池都是系统协调的，String常量池比较特殊，其主要使用方法有两种
			直接使用双引号声明出来的String对象会直接存储在常量池中；
			使用String中的intern()方法；
	字符串拼接操作
		常量与常量的拼接结果在常量池，常量池中不允许存在相同内容的常量；
		只要其中有一个是变量，结果相当于在堆中new一个字符串，具体内容为拼接的结果 ；
		如果拼接的结果调用intern()方法，则主动将常量池中还没有的字符串对象放入池中，并返回此对象地址；
		s1 + s2的执行细节
			首先new一个StringBulider对象；
			在这个new的对象上调用append()方法将字符串添加到new的这个对象中；
			最后调用toStirng()方法(类似于直接new一个字符串)返回一个字符串（toString()方法中new的String对象不会在常量池中生成一个对应的字符串）；
		注：如果字符串拼接符号左右两边都是字符串常量或常量引用，则仍然使用编译器优化；
			针对与final修饰类、方法、基本数据类型、引用数据类型的量的结构时，能使用final的时候建议使用上；
		拼接操作和append()方法的效率对比
			append()方法的效率要远高于拼接操作
				使用append()方法只需要创建一个StringBuilder对象；
				拼接操作则需要创建多个StringBuilder和String对象；
				拼接操作创建了过多的StringBuilder和String对象，内存占用更大，GC是需要花费的时间就更多；
	intern()的使用
		当字符串调用intern()方法时，如果该字符串已经在字符串常量池中存在，则返回该字符串在常量池中的地址，否则在字符串常量池中创建该字符串并返回地址；
		如果不是用双引号声明的String对象，可以使用String提供的intern()方法，方法会从字符串常量池中查询当前字符串是否存在，若不存在就会将当前字符串放入常量池中；
		如果在任意字符串上调用Stirng.intern()方法，其返回结果指向的那个类实例必须和直接以常量形式出现的字符串实例完全相同；
		intern()方法举例
			String s = new String("1"); //此时常量池中也存在一个"1"，但s指向的是对中间中new的String对象
			s.intern();
			String s2 = "1"; //s2指向的是常量池中的"1"
			System.out.println(s == s2); //此时进行地址的比较显示的是false
			
			String s3 = new String("1") + new String("1"); //字符串拼接后生成的是StringBuilder对象，最后调用String.toString()方法但是不会在常量池中生成"11"，所以s3指向的是new出来的String对象；
			s3.intern(); //s3调用intern()方法后会在常量池中生成一个"11"，然后会将常量池中的"11"的地址指向new出来的String对象
			Stirng s4 = "11"; //因为常量池中的"11"已经指向了堆空间中String对象，所以s4虽然指向了常量池中的"11"，但是最终还是指向了String对象
			System.out.println(s3 == s4); //所以最后的结果为true
		注：对于开发中遇到大量重复的字符串，尤其其中存在很多重复的字符串时，使用intern()可以节省内存空间;
	G1的String去重操作
		当垃圾收集器工作的时候，会访问堆上存活的对象，对每一个访问的对象都会检查是否是候选的要去重的String对象；
		如果是把这个对象的引用插入到队列中等待处理，处理队列的一个元素意味着删除这个元素，然后尝试去重它引用的String对象；
		使用一个hashtable来记录所有的被String对象使用的不重复的char数组，当去重时，会查这张hashtable，看堆上是否存在一个一模一样的char数组；
		如果存在String对象会被调整引用那个数组，释放对原来数组的引用；
		如果查找失败，char数组会被插入到hashtable中；
	