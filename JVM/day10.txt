1、字节码指令
	Java需扭计的指令由一个字节长度的、代表着某种特定操作含义的数字（操作码）以及跟随其后的零至多个代表此操作所需要的参数（操作数）构成，由于Java虚拟机采用面向操作数栈而不是寄存器的结构，所以大多数的指令都不包含操作数，只有一个操作码；
	Java字节码指令的执行模型（不考虑异常处理）
		do{
			自动计算PC寄存器；
			根据PC寄存器的指示位置；
			if(字节码存在操作数)从字节码流中取出操作码；
			执行操作码所定义的操作；
		}while(字节码长度>0)
	Java虚拟机的指令集中大多数指令都包含了其操作所对应的数据类型信息（例如iload，表示从局部变量表中加载int型数据到操作数栈中）；
		大多数与数据类型相关的字节码指令，它们的操作码主机符中都有特殊的字符来表明专门为哪种数据类型服务
			i --> int;
			l --> long;
			s --> short;
			b --> byte;
			c --> char;
			f --> float;
			d --> double;
			a --> 引用类型;
		也有一些指令的主机符中么有明确指明操作数类型的字母(如arraylength指令，它没有代表数据类型的特殊字符，但操作数永远只能是一个数组类型的对象)；
		另外一些指令与数据类型无关(如goto)；
		注：对于非int型的数据类型，编译器会在编译期或运行期将其转换为int型；
	加载与存储指令
		加载和存储指令用于将数据从栈帧的局部变量表和操作数栈之间来回传递；
		常用指令
			局部变量压栈指令：将一个局部变量加载到操作数栈xload、xload_<n>（其中x为i、l、f、d、a，n为0-3）；
			常量入栈指令：将一个常量加载到操作数栈bipush、sipush、ldc、ldc_w、ldc2_w、aconst_null、iconst_m1、iconst_<i>、lconst_<l>、fconst_<f>、dconst_<d>；
			出栈装入局部变量表指令：将一个数值从操作数栈存储到局部变量表：xstore、xstore_<n>（其中x为i、l、f、d、a，n为0-3）；
			扩充局部变量表的访问索引的指令：wide；
		压栈指令（xload_<n>）
			将局部变量表中第n个局部变量压入操作数栈；
			常量入栈指令（iconst_<i>(i从-1到5)、lconst_<l>(l从0到1)、fconst_<f>(f从0到2)、dconst_<d>(d从0到1)、aconst_null）
				每个数据类型都有其对应的范围，如果常量值超过了其范围则需要使用push指令；
					push指令
						主要包括bipush和sipush，bipush接收8位正数作为参数，sipush接收16位正数，他们都将参数压入栈；
					ldc指令
						若push指令也无法将操作数压入栈，则使用ldc指令；
						ldc指令接收一个8位参数，该参数指向常量池中的int、float或着String的索引；
						ldc_w接收两个8位参数，能支持的索引内容压入堆栈；
						如果要压入的数据是long或double类型，则使用ldc2_w指令；
		出栈指令(xstore、xstore_<n>（其中x为i、l、f、d、a，n为0-3）)
			将操作数栈中栈顶元素弹出后，装入局部变量表的指定位置，用于给局部变量赋值；
			注：将数据保存在局部变量表中时，操作数栈中的值会出栈；
	算数指令
		算术指令用于对两个操作数栈上的值进行某种特定运算，并把结果重新压入操作数栈；
		算数指令可以分为整型数据进行运算和对浮点类型数据进行运算的指令；
		算数指令种类
			加法指令：iadd、ladd、fadd、dadd
			减法指令：isub、lsub、fsub、dsub
			乘法指令：imul、lmul、fmul、dmul
			除法指令：idiv、ldiv、fdiv、ddiv
			求余指令：irem、lrem、frem、drem
			取反指令：ineg、lneg、fneg、dneg
			自增指令：iinc
				注：++i在字节码文件里是先把局部变量表中的数据加1，再存入操作数栈中，再存入局部变量表中；
					i++在字节码文件里是先把局部变量表中的数据加1，再把操作数栈中的数据存入局部变量表中；
			位运算指令
				位移指令：ishl、ishr、iushr、lshl、lshr、lushr
				按位或指令：ior、lor
				按位与指令：iand、land
				按位异或指令：ixor、lxor
			比较指令：dcmpg、dcmpl、fcmpg、fcmpl、lcmp
				首字符d表示double，f表示float，l表示long；
				对于double和float类型的数字，由于NaN的存在，各有两个版本的比较指令，如果遇到NaN值，处理结果会不一样
					f/dcmpg和f/dcmpl从栈中弹出两个操作数v1和v2进行比较，若v1=v2则压入0，若v1>v2，则压入1，若v1<v2则压入-1；
					如果遇到NaN值，f/dcmpg会压入1，而f/dcmpl会压入-1；
				注：比较指令中没有int类型的操作指令是因为上述指令将一个int型数据压入栈中，条件跳转指令恰恰需要一个int型数据，若两个int型指令进行比较则需要使用比较条件跳转指令；
		注：运算模式分为向最接近数舍入模式和向零舍入模式；
	类型转换指令
		类型转换指令可以将两种不同的数值类型进行相互转换（除boolean类型以外的7中数据类型）；
		一般用于实现用户的显示类型转换操作或者用来处理字节码指令集中数据类型象关指令无法与数据类型一一对应的问题；
		宽化类型转换
			转换规则
				小范围类型向大范围类型的安全转换
					从int型到long、float或者double类型，指令为i2l、i2f、i2d；
					从long型向float、double类型，指令为l2f、l2d；
					从float类型到double类型，指令为f2d；
					注：简化为int-->long-->float-->double；
						对于byte、short和char转换为容量大的类型时，将这些类型视为int型；
			精度损失
				转换时int、long向float或者long向double转换时可能会出现精度损失，但是不会抛出运行时异常；
		窄化类型转换
			窄化转换规则
				int类型向byte、short、char类型转换，指令为i2b、i2c、i2s；
				long类型向int类型转换，指令为l2i；
				float类型向int或者long类型转换，指令为f2i、f2l；
				double类型向int、long、float类型转换，指令为d2i、d2l、d2f；
				注：有些类型转换过程中会先将类型转换为int类型，再通过int类型转换为对应的数据类型；
					如果一个浮点数进行窄化转换为整型类型T（int或long）
						如果浮点数为NaN，则转换结果为int或者long的0；
						如果不是无穷大，则采用向零摄入模式取整，获得整数值v，如果v在目标类型T的表示范围内则直接转换成v，否则将根据v的符号，转换为T所能表示的最大或最小正数；
					如果一个double类型窄化转为float类型时
						如果转换结果的绝对值太小而无法使用float来表示，则返回float类型的正负零；
						如果转换结果的绝对值太大而无法使用float来表示，将范围float类型的正负无穷大；
						对于double类型的NaN值，将按照规定转换为float类型的NaN；
			精度损失问题
				作为强制类型转换，转换的结果具备不同的正负号、不同的数量级，因此转换过程中很可能导致数值丢失精度，同样不会抛出异常；
		对象的创建与访问指令
			创建指令
				创建类实例的指令（new）
					接受一个操作数（指向常量池索引，标识为要创建的类型），执行完成后将对象的引用压入栈；
					创建类实例的过程
						首先通过new关键字在常量池中的找到创建的类实例的类型，并存入栈中；
						再通过dup指令将栈中的对象实例地址复制一份，存入栈中；
						再调用对象的初始化方法（<init>），从操作数栈中取出一个该对象的地址，用于对象的初始化；
						最后将操作数栈中的对象地址保存在局部变量表中；
				创建数组的指令
					newarray：创建基本类型数组；
					anewarray：创建引用类型数组；
					multianewarray：创建多维数组；
					数组创建的过程
						首先将数组长度的初始化值压入栈中；
						再根据创建的数组类型调用合适的字节码指令；
						注：若创建的是多维数组，且数组的第二个初始化参数为空，则调用的依然是引用类型的字节码指令（因为此时仍然只是相当于在堆空间创建了一个引用类型的数组，并没有给数组中的每一个引用类型进行初始化操作）；
			字段访问指令
				访问类字段（static字段）的指令：getstatic、putstatic；
				访问类实例字段（非static字段）的指令：getfield、putfield；
				注：访问非静态属性前需要先将该属性的对象地址压入栈中；
			数组操作指令
				把一个数组元素加载到操作数栈的指令xaload（x为数据类型）；
				把一个操作数栈的值存储到数组元素的指令xastore（x为数据类型）；
				取数组长度的指令arraylength；
				注：在执行xaload之前时，需要操作数栈栈顶的2个元素，数组索引和数组引用，并将a[i]重新压入堆栈；
					在执行xastore指令时，需要操作数栈栈顶的3个元素：值、索引和数组引用；
					在执行arraylength时，先弹出栈顶的数组地址，再将长度压入栈中
			类型检查指令
				检查类实例或数组类型的指令：instanceof、checkcast
					checkcast指令用于检查类型强制转换是否可以进行，那么checkcast指令不会改变操作数栈，否则会抛出ClassCastException异常；
					instanceof指令用来判断给定对象是否是某一个类的实例，它会将判断结果压入栈中；
					注：代码中使用instanceof指令时，在字节码文件里会先调用instanceof指令进行判断再调用checkcast指令判断是否可以强转；
			方法调用与返回指令
				方法调用指令
					invokevirtual指令（除了以下3个指令调用的方法外，都由invokevirtual调用）
						调用对象的实例方法，根据对象的实际类型进行分派，支持多态（调用可能会重写的方法）；
					invokeinterface指令
						调用接口方法，运行时搜索特定对象所实现的这个接口方法，并找出适合的方法进行调用；
					invokespecial指令
						用于调用一些特殊处理的实例方法，包括实例初始化方法(构造器)、私有方法和父类方法（都是静态类型绑定）；
					invokestatic指令
						调用命名类中的static方法（静态绑定）；
					invokedynamic指令
						用于在运行时动态解析出调用点限定符所引用的方法，并执行该方法；
				方法返回指令
					方法调用结束时，需要进行返回。方法返回指令是根据返回值的类型区分
						ireturn（当返回值是boolean、byte、char、short和int类型时使用）、lreturn（long类型）、freturn（float类型）、dreturn（double类型）和areturn（引用类型）；
						return（返回值是void类型）；
						注：通过xreturn指令，将当前函数操作数栈的顶层元素弹出，并将这个元素压入到调用者函数的操作数栈中，所有当前函数操作数栈中的其它元素都会被丢弃；
							如果当前返回的是syschronized方法，那么还会执行一个隐含monitorexit指令，退出临界区（同步指令详细介绍）；
			操作数栈管理指令
				JVM提供的操作数栈管理指令，可以用于直接操作操作数栈的指令；
				操作数栈管理指令内容
					将一个或两个元素从栈顶弹出并且直接废弃：pop，pop2；
					赋值栈顶一个或两个数值并将复制值或两份的复制值重新压入栈顶：dup、dup2、dup_x1、dup、dup2、dup_x1、dup2_x1、dup_x2、dup2_x2；
					将栈最顶端的两个Slot数值位置交换：swap（Java虚拟机没有提供交换两个64位数据类型数值的指令）；
					nop指令，表示什么都不做，这条指令一般可用于调试、占位等；
					注：dup开头的是复制1个Slot的数据；
						dup2开头的指令是用于复制2个Slot的指令；
						dup指令中带_x的指令是复制栈顶数据并插入栈顶以下的某个位置（具体的插入位置是将指令的dup和x的系数相加，结果即为插入的位置，如dup_x1表示位插入栈顶2个Slot下面）；
						pop，将栈顶的一个Slot数值出栈；
						pop2，将栈顶的两个Slot数值出栈；
						以上的所有指令都是通用类型，无需指明数据类型；
			控制转移指令
				条件跳转指令
					条件跳转指令通常是和比较指令结合使用，一般在使用比较指令进行栈顶元素的准备，然后进行条件跳转；
					条件跳转指令内容（这些指令都接收两个字节的操作数，用于计算跳转的位置）
						ifeq：当栈顶int数值等于0时跳转；
						iflt：小于0时跳转；
						ifle：小于等于0时跳转；
						ifne：不等于0时跳转；
						ifgt：大于0时跳转；
						ifge：大于等于0时跳转；
						ifnull：为null时跳转；
						ifnonull：不为null时跳转；
						上述指令表示弹出栈顶元素，测试它是否满足某一条件，如果满足条件，则跳转到给定的位置；
					注：对于boolean、byte、char、short类型的条件分支比较操作，都是使用int类型的比较指令完成；
						对于long、float、double类型的条件分支比较操作，则会先执行相应类型的比较运算指令，运算指令会返回一个整型值到操作数栈中，然后再使用条件跳转指令进行跳转；
				比较条件跳转指令
					比较条件跳转指令主要是用于比较int类型和引用类型；
					比较条件跳转指令如下
						if_icmpeq：比较栈顶两个int类型数值大小，前者等于后者时跳转；
						if_icmpne：前者不等于后者时跳转；
						if_icmplt：前者小于后者时跳转；
						if_icmpgt：前者大于后者时跳转时；
						if_icmple：前者小于等于后者时跳转；
						if_icmpge：前者大于等于后者时跳转；
						if_acmpeq：比较栈顶两个引用类型数值，当结果相等时就跳转；
						if_acmpne：当结果不等时就跳转；
						注：这些指令都接收两个字节的操作数作为参数，用于计算跳转的位置，同时执行指令时，栈顶需要准备两个元素进行比较，指令执行完后，栈顶的两个元素被清空，且没有任何数据入栈；
				多条件分支跳转指令
					多条件分支跳转指令专为switch-case语句设计，主要有tableswitch和lookupswitch
						tableswitch：用于switch条件跳转，case值连续；
						lookupswitch：case值不连续；
						注：tableswitch要求多个条件分支值是连续的，它内部只存放起始值和终止值，通过给定的操作数index，可以立即定位到跳转偏移量位置，因此效率比较高；
							lookupswitch内部存放着离散的case-offset对，每次执行都要搜索全部的case-offset对，找到匹配的case值，并根据对应的offset计算跳转地址，因此效率低；
							lookupswitch在字节码里会按照case后的数值大小进行排序；
							判断字符串类型的值时，在字节码里会将其用hash值表示出来；
				无条件跳转指令
					指令goto接收两个字节的操作数，共同组成一个带符号的证书，用于指定指令的偏移量，指令执行的目的就是跳转到品一辆给定的位置处；
					如果偏移量太大，超过双字节的带符号证书的范围，则可以使用goto_w（接收资格字节的操作数）；
				抛出异常指令
					Java程序中显示抛出异常的操作都是由athrow指令实现；
					除了使用throw语句显示抛出异常情况之外，JVM还规定了许多运行时异常会在其他Java虚拟机指令检测到异常状况时自动抛出；
					异常及异常处理
						异常对象的生成过程-->throw（手动、动作） --> 指令：athrow；
						异常的处理：抓抛模型--> try-catch-finally --> 使用异常表；
					异常处理与异常表
						处理异常
							在Java虚拟机中，处理异常（catch语句）不是由字节码指令来实现，而是采用异常表来完成；
						异常表
							如果一个方法定义了一个try-catch或try-finally的异常处理，就会创建一个异常表，包含了每个异常处理或finally块的信息
								起始位置：try语句的开始位置；
								结束位置：try语句的结束位置；
								程序计数器记录的代码处理的偏移地址：若发生异常时要跳转到的偏移地址所在的字节码处接着执行（catch部分的代码）；
								被捕获的异常类在常量池中的索引：在异常表中标注catch中要捕获的异常类型信息，存储在常量池中；
					注：在抛出异常时，Java虚拟机会清除操作数栈上的所有内容，而后将异常实例压入调用者操作数栈上；
						不管什么时候抛出异常，如果异常处理最终匹配所有异常类型，代码就会继续执行；
				同步控制指令
					方法级同步
						方法级同步是隐式的，无需通过字节码指令来控制，它实现在方法方法调用和返回操作之间（在方法的方法访问标志中会有标记ACC_SYNCHRONIZED）；
						方法调用时会检查方法的ACC_SYNCHRONIZED访问标志是否设置
							如果设置了，执行线程将先持有同步锁，然后执行方法，最后在方法完成后释放听不锁（不管是正常完成还是非正常完成）；
							在方法执行期间，执行线程只有了听不锁，其他任何线程都无法再获得一个锁；
							如果一个同步方法执行期间抛出了异常，并且在方法内部无法处理此异常，那这个同步方法所持有的锁将在异常抛到同步方法之外时自动释放；
							注：当虚拟机通过方法的访问标识判断是一个同步方法时，会自动在方法调用前进行加锁；
					方法内指定指令序列的同步
						同步一段指令集序列通常是由java中的synchronized语句块来表示，jvm的指令集有monitorenter和monitorexit两条指令来支持sychronized关键字的语义；
						当一个线程进入同步代码块时，它使用monitorenter指令请求进入，如果当前对象的监视器计数器为0，则它会被准许进入，若为1，则判断持有当前监视器的线程是否为自己，如果是则进入，否则进行等待，知道对象的监视器计数器为0，才会被允许进入同步块；
						当线程退出同步块时，需要使用monitorexit声明退出，在java虚拟机中，任何对象都有一个坚持其与之相关联，用来判断对象是否被锁定，当监视器被持有后，对象处于锁定状态；
						指令monitorenter和monitorexit在执行时，都需要在操作数栈顶压入对象，只有monitorenter和monitorexit的锁定和释放都是整堆这个对象的监视器进行的；
						注：对象的内部结构的对象头中有一个属性是锁状态标志，当调用monitorenter指令时，将该对象的锁状态标志由0变为1（线程持有的锁属性也会记录当前锁是被哪一个线程持有）；
							同步代码会在异常表中自动地添加一个异常处理（异常类型为任何异常，代码中不会显示出捕获异常的代码），当同步代码块中出现了异常，便会跳转到处理异常的字节码部分进行该线程释放锁的操作，并抛出异常信息；
