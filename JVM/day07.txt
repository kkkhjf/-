1、垃圾回收
	在运行程序中没有任何指针指向的对象，这个对象就是需要被回收的垃圾；
	GC的作用区域（堆和方法区），频繁收集新生代，较少收集老年代，基本不动元空间；
2、垃圾回收算法
	标记阶段
		GC执行前，首先需要区分出内存中哪些对象是存活哪些对象是死亡；
		引用计数算法
			设计思想
				对每个对象都保存一个整型的引用计数器属性，用于记录对象被引用的情况；
			优缺点
				优点
					实现简单，垃圾对象便于辨识；判断效率高，回收没有延迟性；
				缺点
					需要单独的字段存储计数器，增加了存储空间的开销；
					每次赋值需要更新计数器，伴随着加减法，增加了时间开销；
					无法处理循环引用的情况（如果循环引用的情况，其中每个对象的引用计数器都不为0，所以就没有办法回收了出现了内存泄漏）
		可达性算法
			设计思想
				以根对象（一组必须活跃的引用）集合为起始点，按照从上至下的方式搜索被根对象集合所连接的目标对象是否可达；
				使用可达性算法后内存中的存活对象都会被根对象集合直接或间接连接着，搜索走过的路径称为引用链；
				如果目标对象没有任何引用链相连，则是不可达，就意味着该对象已经死亡，可以标记为垃圾对象；
				在可达性算法中，只有能够被根对象集合直接或间接连接的对象才是存活对象；
			GC Roots包括以下几类元素
				虚拟机栈中引用的对象
					各个线程被调用的方法中使用到的参数、局部变量；
				本地方法栈内JNI（通常说的是本地方法）引用的对象；
				方法区中类静态属性引用的对象
					Java类的引用类型静态变量；
				方法区中常量引用的对象
					字符串常量池里的引用；
				所有被同步锁synchronized持有的对象；
				Java虚拟机内部的引用
					基本数据类型对应的Class对象，一些常驻的异常对象（NullPointerException、OutOfMemoryError等），系统类加载器；
				反映Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等；
				还有一些特殊情况（分代收集和局部回收）
					如果只针对Java堆中的某一块区域进行垃圾回收，必须考虑到内存区域是虚拟机自己的实现细节，更不是鼓励封闭的，这个区域的对象完全又肯呢被其他区域的对象所引用，这时候就需要一并将关联的区域对象也加入GC Roots集合中去考虑，才能保证可达性分析的准确性；
				注：如果一个指针，它保存了堆内存里面的对象，但是自己又不存放在对内存里面，那它就是一个Root；
					使用可达性分析算法来判断内存是否可以回收，那么分析工作必须在一个能保证一致性（对对象是否被引用的能有准确的标识）的快照中进行，这也是导致GC进行时必须STW的一个重要原因；
		对象的finalization机制
			当垃圾回收器发现没有引用指向一个对象，即垃圾回收此对象前，总会先调用这个对象的finalize()方法；
			finalize()方法允许在字类中被重写，用于在对象被回收时及逆行资源释放，通常在这个方法中进行一些资源释放的清理工作，比如关闭文件、套接字和数据库连接等；
			不要主动调用某个对象的finalize()方法，应该交给垃圾回收机子调用
				在finalize()时可能会导致对象复活；
				finalize()方法的执行时间是被有保障的，它完全由GC线程决定，极端情况下，若不发生GC，则finalize()将没有机会执行；
				一个糟糕的finalize()会严重影响GC性能；
			从功能上来说finalize()方法与C++中的析构函数比较相似，本质上还是不同于析构函数；
			由于finalize()方法的存在，虚拟机中的对象一般处于三种可能的状态
				可触及的
					从根节点开始可以到达这个对象；
				可复活的
					对象的所有引用都被释放，但是对象有可能在finalize()中复活；
				不可触及的
					对象的finalize()被调用，并且没有复活，那么就会进入不可触及状态，不可触及的对象不可能被复活，因为finalize()只会被调用一次；
			判断一个对象是否可回收，至少要经历两次标记过程
				如果对象到GC Roots没有引用链，则进行一次标记；
				如果筛选，判断此对象是否有必要执行finalize()方法
					如果对象没有重写finalize()方法，或者finalize()方法已经被虚拟机调用过，则虚拟机视为"没有必要执行"，该对象被判定为不可触及；
					如果对象重写了finalize()方法，且还未执行过，那么该对象会被插入到F-Queue队列中，由一个虚拟机自动创建的、低优先级的Finalizer线程触发其finalize()方法执行；
					finalize()是对象逃脱死亡的最后机会，稍后GC会对F-Queue队列中的对象进行第二次标记，如果该对象在finalize()方法中与引用链上的任何一个对象建立联系，那么第二次标记时该对象会被移除"即将回收"集合，之后该对象再次出现没有引用的情况，finalize()不会被调用，该对象直接被视为不可触及，也就是说finalize()方法只会被调用一次；			
	清除阶段
		标记-清除算法
			算法思想
				当堆中的有效内存空间被耗尽时，就会停止整个程序（STW），然后进行两项工作，第一则是标记，第二项则是清楚
					标记
						Collector从引用根节点开始遍历，标记所有被引用的对象，一般是在对象头中记录为可达对象；
					清除
						Collector对堆内存从头到尾进行线性的遍历，如果发现某个对象在其对象头中没有标记为可达对象，则将其回收；
					注：清除不是真的置空，而是把需要清除的对象地址保存在空闲的地址列表里，下次有新对象需要加载时，判断位置空间是否够，如果够就直接覆盖；
			优缺点
				缺点
					效率不高，在进行GC的时候，需要停止整个应该程序，导致用户体验差；
					这种方式清理出来的空闲内存是不连续的，产生内存碎片，需要维护一个空闲列表；
				优点
					实现简单；
		复制算法
			算法思想
				将活着的内存空间分为两块，每次只使用其中一块，在垃圾回收时将正在使用的内存中的存活对象赋值到未被使用的内存块中，之后清除正在使用的内存块中的所有对象，交换两个内存的角色，最后完成垃圾回收；
			优缺点
				优点
					没有标记和清除过程，实现简单，运行高效；
					复制获取以后保证空间的连续性，不会出现碎片问题；
				缺点	
					需要两倍的内存空间；
					对于G1这种分拆成为大量region的GC，复制而不是移动，意味着GC需要维护region之间对象引用关系，不管是内存占用或者时间开销也不小；
					如果存活的对象很多复制算法效率不高；
		标记-压缩算法
			算法思想
				第一阶段和标记-压缩算法一样，从根节点开始标记所有被引用的对象；
				第二阶段将所有存活的对象压缩到内存的一端，按顺序排放；
			优缺点
				优点
					消除了标记-清除算法当中，内存区域分散的缺点，我们需要给新对象分配内存时，JVM只需要只有一个内存的起始地址即可；
					消除了复制算法中内存减半的高额代价；
				缺点
					从效率上来说，标记-整理算法要低于复制算法；
					移动对象的同时，如果对象被其他对象引用，则还需要调整引用的地址；
					移动过程中，需要全程暂停用户应用程序，即STW；
	分代收集算法
		算法思想
			不同的对象的生命周期是不一样的，不同的生命周期可以采取不同的收集方式，以便提高回收效率；
		GC中采用的是分代收集算法
			年轻代因为区域小、对象生命周期短、存活率低，回收频繁所以适合复制算法；
			老年代区域大，对象生命周期长、存活率高，回收不及年轻代频繁，所以一般使用标记-清除或标记-清除与标记-整理混合使用；
				Mark阶段的开销与存活对象的数量成正比；
				Sweep阶段的开销与所管理区域的大小成正比；
				Compact阶段的开销与存活对象的数据成正比；
	增量收集算法
		算法思想
			每次垃圾收集线程只收集一小片区域的内存空间，接着切换到应用程序线程，一次反复知道垃圾收集完成；
			增量收集算法的基础仍是传统的标记-清除和复制算法，增量收集算法通过对线程冲突的妥善处理，允许垃圾收集线程以分阶段的方式完成标记、清除和复制工作；
		优缺点
			优点
				在垃圾回收过程中，间断性地执行了应用程序代码，可以减少系统得停顿时间；
			缺点
				线程切换和上下文转换地消耗，会使得垃圾回收的总成本上升，造成系统吞吐量地下降；
	分区算法
		算法思想
			将一块大的内存区域分割成多个小块，根据目标停顿时间，每次合理地回收若干个小区间，而不是整个堆空间，从而减少一次GC所产生的停顿；
3、垃圾回收相关概念
	System.gc()理解
		默认情况下，通过System.gc()或者Runtime.getRuntime().gc()地调用，会显式触发Full GC，同时对老年代和新生代进行回收，尝试释放被丢弃对象占用的内存（一般情况下，内存回收是自动进行无须手动触发）；
		调用System.gc()并不能保证每次都会调用垃圾收集器；
	内存溢出和内存泄露
		内存溢出
			没有空闲内存，并且垃圾收集器也无法提供更多内存（内存溢出前会调用一次Full GC）；
		内存泄露
			只有对象不会再被程序用到了，但是GC又不能回收他们的情况，才叫内存泄漏；
			内存泄露举例
				单例模式
					单例模式的生命周期和应用程序一样长，所以单例程序中，如果持有对外部对象的引用时，那么这个外部对象是不能被回收的，则会导致内存泄露的产生；
				一些提供close的资源未关闭导致内存泄漏
					数据库连接，网络连接和io连接必须手动close，否则是不能被回收；
	Stop The World
		STG指的是GC时间发生过程，会产生程序的停顿，停顿时整个应用程序都会被暂停，没有任何响应；
		STW事件和采用哪种GC无关，所有的GC都有这个事件；
		STW是JVM在后台自动发起和自动完成的，System.gc()会导致STW的发生；
	安全点与安全区域
		安全点
			程序只有在特定的地方才能停下来开始GC，安全点如果太少可能导致GC等待时间太长，如果太频繁可能导致运行时的性能问题；
			GC发生时，检查所有线程都跑到最近的安全点停顿
				主动式中断：设置一个中断标志，各个线程运行到安全点的时候主动轮询这个标志，如果中断位置为真，则将自己进行中断挂起；
		安全区域
			程序在执行到一个范围内都是可以直接GC的；
	四种引用
		强引用（大部分场景都会使用）
			在程序代码之中普遍存在的引用赋值，类似于Object obj = new Object()，无论任何情况下只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象；
			默认使用强引用，强引用的对象是可触及的；
			对于一个普通对象，如果没有其他的引用关系，只要超过了引用的作用域或者显式地将相应（强）引用赋值为null，就是可以当作垃圾被回收；
		软引用（缓存中使用）
			在系统将要发生内存溢出之前，将会把这些对象列入回收范围之中进行第二次回收，如果这次回收后还没有足够的内存才抛出内存溢出异常；
			
		弱引用（缓存中使用）
			被弱引用关系到的对象只能生存到下一次垃圾收集之前，当垃圾收集器工作时，无论内存空间是否足够都会回收掉弱引用关联的对象；
			由于垃圾回收线程优先级比较低，因此并不一定能很快的发现持有的弱引用对象，在这种情况下弱引用对象可以存在较长地时间；
		虚引用
			唯一目的就是能在这个对象被收集器回收时收到一个系统通知；
			虚引用在创建地时候必须提供一个引用队列作为参数，当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象后将这个虚引用加入引用队列，以通知应用程序对象的回收情况；
			由于虚引用可以跟踪对象地回收时间，因此也可以将一些资源释放操作放置在虚引用中执行和记录；
		