2、运行时数据区
	运行时数据区组成：方法区（进程）、堆（进程）、程序计数器（线程）、本地方法栈（线程）和虚拟机栈（线程）；
	线程
		线程是一个程序里的运行单元，JVM允许一个应用有多个线程并行的执行；
		Hotspot JVM里每个线程都与操作系统的本地线程直接映射
			当一个Java线程准备好执行以后，此时一个操作系统的本地线程也同时创建，Java线程执行终止后，本地线程也会回收；
		一旦本地线程初始化成功，它就会调用Java线程中的run()方法；
		Hotspot JVM里后台主要的系统线程
			虚拟机线程
			周期任务线程
			GC线程
			编译线程
			信号调度线程
			
	程序计数器（PC寄存器）
		JVM的PC寄存器是对物理PC寄存器的一个抽象模拟；
		PC寄存器是用来存储指向下一条指令的地址，即将执行的指令代码，由执行引擎读取下一条指令；
		JVM规范中，每个线程都有它自己的程序计数器，是线程私有的，生命周期与线程的生命周期保存一致；
		任何时间一个线程都只有一个方法在执行，即本地方法，程序计数器会存储当前线程正在执行的本地方法的JVM指令地址，若执行的是native方法则标识为未指定；
		它是程序控制流的指示器，分支、循环、跳转、异常处理和线程恢复等基础功能都需要依赖这个计数器；
		字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令；
		它是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域；
		程序计数器存储字节码指令的作用
			因为CPU需要不停地切换各个线程，这个时候切换回来以后，就得知道接着从哪开始继续执行；
	
	虚拟机栈
		每个线程在创建时都会创建一个虚拟机栈，其内部保存着一个个栈帧，对应着一次次地Java方法调用（是线程私有）；
		生命周期和线程一致；
		主管Java程序的运行，它保存方法的局部变量（8种基本数据类型、对象的引用地址）、部分结果，并参与方法的调用和返回；
		栈的特点
			栈是一种快速有效的分配存储方式，访问速度仅次于程序计数器；
			JVM直接对Java栈的操作只有两个（每个方法执行时进栈，结束时出栈）；
			对于栈来说不存在垃圾回收问题；
		虚拟机栈的异常
			Java虚拟机可以设置Java栈的内存为动态或固定不变
				固定不变会产生StackOverflowError异常；
				动态扩展会产生OutOfMemoryError异常；
			设置栈大小的参数指令
				-Xss
					-Xss后面直接填写想要调整的栈大小，默认是以bytes为单位，数字后面加k或K表示KB，加m或M表示MB；
		虚拟机栈的存储
			栈中的数据都是以栈帧的格式存在（这个线程上正在执行的每一个方法都对应着一个栈帧）；
			栈帧是一个内存区块，是一个数据集，维系着方法执行过程中的各种数据信息；
			一个时间点上只有一个活动的栈帧，即只有当前正在执行的栈帧是有效的，这个栈帧被称为当前栈帧，与这个栈帧对应的方法就是当前方法；
			执行引擎运行的所有字节码指令只对当前栈帧进行操作；
			如果该方法中调用了其他方法，对应的新的栈帧就会被创建出来，放在栈的顶端称为新的当前栈帧；
		栈运行原理
			不同线程中所包含的栈帧是不允许存在相互引用的，即不可能在一个栈桢之中引用另外一个线程的栈帧；
			如果当前方法调用了其他方法，方法返回之际，当前栈帧会回传此方法的执行结果给当前一个栈帧，虚拟机会丢弃当前栈帧，使得前一个栈帧重新称为当前栈帧；
			Java方法有两种返回函数的方式，一种是正常函数返回（return，每个方法的字节码文件里都会有一个return），另一种是抛出异常（没有处理的异常），不管使用哪种方式，都会导致栈帧被弹出；
		栈帧的内部结构
			局部变量表
				局部变量表定义为一个数字数组；
					参数值存放总是在局部变量数组的index0开始，到数组长度-1的索引结束；
					局部变量表最基本的存储单元是Slot（变量槽）
						局部变量表最基本的存储单元是Slot（变量槽）；
						局部变量表中32位以内的类型只占一个slot（包括returnAddress类型），64位类型（long和double）占两个solt
							byte、short、char在存储前被转换成int，boolean也被转换为int（0表示false，非0表示true）；
							long和double则占据两个solt；
						如果当前帧是由构造方法或实例方法创建的，那么该对象引用this将会存放在index为0的slot处，其余的参数按照参数表顺序继续排列；
						访问占据2个solt的变量时，使用的是其前一个索引；
						栈帧中的slot槽位可以重复利用；
					局部变量表主要用于存储方法参数和定义在方法体内的局部变量（基本数据类型、对象引用以及返回值类型）；
				局部变量表是线程私有数据，因此不会有线程安全问题；
				局部变量表所需的容量大小在编译期间就已经确定下来，并保存在方法的Code属性的mximum local variables数据项中，在方法运行过程中不会改变；
				局部变量表中的变量只在当前方法中有效，在方法执行时，虚拟机通过使用局部变量表完成参数值到参数变量列表的传递过程，当方法调用结束后，随着方法栈帧的销毁，局部变量表也会随之销毁；			
				变量的分类
					成员变量（在使用前都经历默认初始化赋值）
						类变量：连接的准备阶段给类变量默认赋值，初始化阶段给类变量显示赋值即静态代码块赋值；
						实例变量：随着对象的创建，会在堆空间中分配实例变量空间，并进行默认赋值；
					局部变量（在使用前必须进行显式赋值，否则编译不通过）
				局部变量表中的变量也是重要的垃圾回收根节点，只要被局部变量表中直接引用或间接引用的对象都不会被回收；
			操作数栈
				在方法执行过程中，根据字节码指令往栈中写入数据或提取数据；
				操作数栈主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间；
				当一个方法刚开始执行的时候，一个新的栈帧也会随之被创建，这个方法的操作数栈是空的；
				每个操作数栈的大小在编译期间就确定了，保存在Code属性中，为max_stack的值；
				栈中的任何一个元素都可以是任意的Java数据类型（32bit的类型占用一个栈单位，64bit占据两个栈单位）；
				操作数栈并非采用访问索引的方式进行访问数据，只能通过标准的入栈和出栈来完成一次数据的访问；
				如果被调用的方法带有返回值，其返回值将被压入当前栈帧的操作数栈中，并更新PC寄存器中吓一跳需要执行的字节码指令；
			动态链接（指向运行时常量池的方法引用）
				每一个栈帧内部都包含一个指向运行时常量池中该栈帧所属方法的引用；
				Java源文件被编译到字节码文件中时，所有的变量和方法引用都作为符号引用保存在class文件的常量池中，动态链接就是将这些符号引用转换为调用方法的直接引用；
				常量池的作用
					提供一些符号和常量，便于指令的识别；
			方法调用
				将符号引用转换为调用方法的直接引用与方法的绑定机制相关；
					静态链接
						如果被调用的目标方法在编译期间可知且运行时保持不变，这种情况下将调用方法的符号引用直接转换为直接引用的过程；
					动态链接
						如果被调用的方法在编译期间无法被确定下来，只能在程序运行时将调用方法的符号引用转换成直接引用；
					对应方法的绑定机制
						早期绑定
							调用的目标方法在编译期可知，且运行期保持不变时，即可将这个方法与所属的类型进行绑定；
						晚期绑定
							被调用的方法在编译期无法被确定下来，只能够在程序运行期根据实际的类型绑定相关方法；
					非虚方法（静态方法，私有方法，final方法，实例构造器和父类方法）
						在编译期间就确定了具体的调用版本，这个版本运行时是不可变的，称这样的方法为非虚方法；
					虚拟机中调用方法的指令
						普通调用
							invokestatic调用静态方法
							invokespecial调用<init>方法、私有方法及父类方法，解析阶段确定唯一方法版本
							invokevirtual调用所有虚方法（final修饰的除外）
							invokeinterface调用接口方法
							注：invokestatic和invokespecial调用的都是非虚方法；
						动态调用
							invokedynamic动态解析出需要调用的方法，然后执行；
					方法重写的本质
						找到操作数栈顶的第一个元素所执行的对象的实际类型；
						如果在该对象的实际类型中找到调用的方法，则进行类型检查如果通过则返回这个方法的直接引用，否则抛出异常；
						如果在当前实际类型中没有找到合适的方法，则在父类中查找；
						如果始终没有找到合适的方法则抛出异常；
			方法返回地址（方法正常退出或异常退出的定义）
				存储该方法的PC寄存器的值；
				返回指令包含ireturn、lreturn、freturn、dreturn以及areturn；
				出现异常，并且在本方法的异常表中没有搜索到匹配的异常处理器就会导致方法的退出；
			一些附加信息
				栈帧允许携带与虚拟机实现相关的一些附加信息，例如对程序调试提供支持的信息；
			注：栈帧的内部结构影响栈帧的大小，栈帧的大小又影响栈中存放的栈帧数量；
		