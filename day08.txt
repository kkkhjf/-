1、super关键字
    格式：
        super.属性或方法；
    super关键字的使用：
        在子类的方法或构造器中可以通过“super.属性或方法”的方式显式地调用父类中声明的属性或方法；
        在特殊情况下，当子类和父类中定义了属性和方法可以利用super关键字区分子类父类的属性或方法；
        当子类重写了父类的方法时，在子类中调用父类被重写的方法可以使用super关键字；
    super在构造器中使用：
        在子类构造器中显式的使用“super（形参列表）”的方式，调用父类中声明的构造器；
        “super（形参列表）”必需声明在子类构造器的首行；
        对于this（形参列表）和super（形参列表）只能二选一；
        在构造器的首行，没有显示的声明this（参数列表），默认调用super（参数列表）；
        在类的多个构造器中至少有一个类的构造器使用super（参数列表）。
        
2、子类对象全过程
    从结果上看：
        子类继承父类以后，就获得了父类中声明的属性和方法；
        创建子类的对象，在堆空间中，就会加载所有父类声明的属性。
    从过程上看：
        当我们通过子类的构造器创建子类对象时，一定会直接或间接的调用父类的构造器，知道调用Object类的空参构造器，
            正因为加载过所有父类的构造器，所以才可以看到内容中有父类的结构，子类对象才可以考虑调用。
        注：子类只是加载父类的构造器，并不是创建父类的对象。  
        
3、多态性
    父类的引用指向子类的对象(Person p1 = new Man())；
    当调用子父类同名同参的方法时，实际执行的是子类重写父类的方法---虚拟方法调用；
    多态的使用：
        有了对象的多态性后，在编译过程中只能调用父类中声明的方法，在运行期执行的是子类重写父类的方法。
    多态性使用前提：
        类的继承关系；
        方法的重写。 
    对象的多态性只适用于方法不适用于属性；
    虚拟方法：
        子类中定义了与父类同名同参的方法，在多台情况下，将此时父类中的方法成为虚拟方法，父类
            根据赋给它的不同对象，动态的调用属于子类的该犯法。
    多态性是一个运行时行为。
    
        重载与重写的区别：
            重载在编译期间就绑定好了，多态只有在运行的时候才知道具体的方法执行。

4、instanceof关键字
    a instanceof A :判断对象a是否是类的实例，是则返回true；
    为了避免在向下转移之前出现classcastException异常，转换之前先用instanceof判断一下；

5、向上转移和向下转移
    向上转移：子类引用的对象转换为父类对象（多态）；
    向下转移：父类引用的对象转换成子类类型。
    
6、Object类
    object类是所有Java类的基类；
    类在声明时没有使用extends关键字，则默认父类为java.lang.Object类；
    Object类中的功能具有通用性：
        属性（无）
        方法（equals(/toString()/getClass()/hashCode()/clone()/finalize()/wait()/nofityAll()）
    equals方法：
        equals（）和==的区别：
            ==：运算符使用在基本数据类型和引用数据类型之间，如果是基本数据类型变量，就是比较数据是否相等；如果是引用数据类型则比较地址值是否相同；
            equals（）：只是一个方法，适用于引用数据类型；Object类中定义equals（）和==作用相同；在String、Date、File、包装类等都重写了equals（）方法，比较的是实体内容是否相等；
