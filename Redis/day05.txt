1、Redis持久化操作
    redis提供了两种持久化操作：RDB和AOF；
    RDB（Redis DataBase）
        在指定的时间间隔内将内存中的数据集快照写入磁盘，它回复是将快照我呢见直接读到内存里；
        备份执行
            redis会单独创建一个子进程（fork）来进行持久化操作，会先将数据写入到一个临时文件中，持久化过程都结束了，再用这个临时文件替换上次持久化好的文件，整个
                过程中，主进程是不进行任何IO操作的，这就确保了极高的性能，如果需要进行大规模数据的恢复，且对于数据会的完整性不是非常敏感，那RDB方式要比AOF方式更加
                高效，RDB的缺点是最后一次持久化后的数据可能丢失；
            fork
                fork的作用是复制一个与当前子进程一样的进程，新进程的所有数据（变量、环境变量、程序计数器等）数值都和原进程一致，但是是一个全新的进程，并作为原进程的子进程；
                子进程在此后多会exec系统调用，出于效率考虑，Linux引入“写时复制技术”（fork开辟一个临时空间用来保存数据，只有写完后才会将临时空间中的数据写入到磁盘中替换原数据）；
                一般情况父进程和子进程会共用同一段物理内存，只有进程的各段的内容要发生变化时，才会将父进程的内容复制一份给子进程；
        rdb文件
            redis配置文件中以dbfilename dump.rdb默认将rdb文件名设为dump.rdb，dir ./将文件的rdb文件存储在启动文件的目录中；
        rdb配置
            save：设置redis开始执行持久化操作的条件，后面有两个参数，一个表示时间间隔，另一个表示在该段时间间隔内只要需要改变多少个key就会开始持久化操作；
            dbfilename：设置rdb文件的文件名，默认为dump.rdb；
            dir：设置rdb文件的存储位置，默认为redis启动目录；
            stop-writes-on-bgsave-error：当redis无法写入磁盘的话，直接关掉redis的写操作，yes为启用该策略；
            rdbcompression：设置对存储到磁盘中的快照是否进行压缩存储，yes表示支持该策略（redis采用LZF算法进行压缩）；
            rdbchecksum：数据校验，yes表示支持该策略；
        rdb备份
            将*.rdb文件拷贝到别的地方；
            rdb的恢复
                关闭redis；
                先把备份的文件拷贝到工作目录下，名字要改成dump.rdb；
                启动redis时，备份数据会直接加载；
        rdb优缺点
            优点
                适合大规模的数据恢复；
                对数据完整性和一致性要求不高更适合使用；
                节省磁盘空间；
                恢复速度快；
            缺点
                Fork的时候，内存中的数据被克隆了一份，大致2倍的膨胀性需要考虑；
                在大数据下写时复制技术比较消耗性能；
                在一定的间隔时间做一次备份，redis意外down掉的话就会丢失最后一次快照后的所有修改；
    AOF（Append Only File）
        以日志的形式来记录每个写操作（增量保存），将redis执行过的所有写指令记录下来（读操作不记录），只许追加文件但不可以改写文件，redis启动之初会读取该文件重新构建数据
            redis重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作；
        注：AOF默认不开启；
            AOF和RDB同时开启，系统默认读取AOF；
        开启AOF
            在配置文件中将appendonly no改成appendonly yes；
        AOF生成路径
            配置文件中appendfilename "appendonly.aof"表示aof文件的名字，默认路径就是rdb文件的存储路径；
        AOF启动和恢复
            正常恢复
                AOF备份和恢复的操作和RDB是一样的，先拷贝备份文件，需要恢复时再拷贝到redis工作目录下，启动系统即加载；
            异常恢复
                如果遇到AOF文件损坏，通过/usr/local/bin/redis-check-aof --fix appendonly.aof进行修复；
                备份被写坏的AOF文件；
                重启redis，然后重新加载；
        AOF同步频率设置
            appendfsync always：始终同步，每次redis的写入都会立刻记入日志，性能较差但数完整性比较好；
            appendfsync everysec：每秒同步，每秒记入日志一次，如果宕机，本秒数据可能丢失；
            appendfsync no：redis不主动进行同步，把同步时机交给操作系统；
        Rewrite压缩
            当AOF文件的大小超过所设定的阈值时，redis就会启动AOF文件的内容压缩，只保留可以恢复数据的最小指令集，可以使用命令bgrewriteaof；
            重写原理
                AOF文件持续增长而过大时，会fork出一条新进程来将文件重写（也是先写临时文件最后再rename），redis4.0版本后的重写，就是把rdb的快照，以二进制的形式附在新的aof头部
                    作为已有的历史数据，替换掉原来的流水账操作；
                触发机制
                    redis会记录上次重写时的AOF大小，默认配置释放AOF文件大小是上次rewrite后带线啊哦的一本且文件大与64M时触发；
                    auto-aof-rewrite-percentage：设置重写的基准值，文件达到原来的重写后的2倍时触发；
                    auto-aof-rewrite-min-size：设置重写的基准值，最小文件64MB，达到这个值开始重写；
                重写流程
                    bgrewriteaof触发重写，判断识符但概念有bgsave或bgrewriteaof在运行，如果有，则等待该命令结束后再继续执行；
                    主进程fork出子进程执行重写操作，保证主进程不会阻塞；
                    子进程遍历redis内存中数据到临时文件，客户端的写请求同时写入aof_buf缓冲区和aof_rewrite_buf重写缓存区保证原AOF文件完整以及新AOF文件生成期间的新数据修改动作不会丢失；
                    子进程写完新的AOF文件后，向主程序发信号，父进程更细统计信息，主进程把aof_rewrite_buf中的数据写入到新的AOF文件；
                    使用新的AOF文件覆盖旧地AOF文件，完成AOF重写；
        AOF持久化流程
            客户端的请求写命令会被append到AOF缓冲区；
            AOF缓冲区根据AOF持久化策略（always、everysec、no）将操作sync同步到磁盘的AOF文件中；
            AOF文件大小超过重写策略或手动重写时，会对AOF文件rewrite重写，压缩AOF文件容量；
            redis重启时，会重新加载AOf文件中的写操作，达到数据恢复的目的；
        AOF优缺点
            优点
                备份机制更加稳定，丢失概率更低；
                可读的日志文本，通过操作AOF文件，可以处理误操作；
            缺点
                比起RDB占用更多的磁盘空间；
                恢复备份速度要慢；
                每次独写都同步的话，有一定的性能压力；
                存在个别bug，造成恢复失败；
    注：官方建议AOF和RDB都启用，如果只做缓存处理可以都不开启；
2、主从复制
    主机数据更新后根据配置和策略，自动同步到北极的master/slaver机制，master以写为主，slave以读为主；
    主从复制作用
        读写分离，性能扩展，容灾快速恢复；
    实现一主多从
        创建一个目录，将redis配置文件放入其中；
        创建主从主机的配置文件（通过include命令将redis.conf配置文件中的内容引入，再配置不同的参数即可（修改pdifile、port和dbfilename）），端口号要不一样；
        启动redis，进入redis服务器（redis-cli -p 端口号）使用info replication查看redis服务器情况；
        配置主从机
            redis启动时默认为主机；
            redis服务器中输入slaveof 主机ip 主机端口号 命令，将该redis设置为从机；
            注：从机中只能进行读操作，不能进行写操作；
                从服务器宕机后需要使用slaveof命令重新设置为从服务器，重新设置为从机后会将主机中的数据复制到从机；
                主服务器重启后从服务器仍然是从服务器，主服务器的角色不会改变；
    主从复制原理
        从服务器连接上主服务器后，从服务器会发送进行数据同步消息；
        主服务器接收到从服务器发送过来的同步消息后，把主服务器数据进行持久化，把数据备份进rdb文件，把rdb文件发送给从服务器，从服务器拿到rdb进行读取；
        每次主服务器进行写操作后，和从服务器进行数据同步（主服务器主动进行）；
    薪火相传
        主服务器将数据同步给一些从服务器，这些从服务器再将数据同步给其他从服务器；
        实现过程
            将其他从服务器挂在一台从服务器上；
    反客为主
        当一个主服务器宕机后，后面的从服务器立刻省委主服务器，其他从服务器不做任何修改；
        操作过程
            在一台从服务器上使用slaveof no one命令；
    哨兵模式
        反客为主自动版，能够后台监控主机是否故障，如果故障了根据投票自动将从服务器转为主服务器；
        实现步骤
            在redis工作目录下新建sentinel.conf文件，名字不能错；
            配置sentinel.conf，添加一条命令：sentinel monitor mymaster 主机ip 主机端口号 1
                mymaster为监控对象起的服务器名称；
                1表示至少有多少个哨兵同意迁移的数量；
            启动哨兵使用命令：redis-sentinel 配置文件的目录；
            选举新主机的规则
                选择优先级靠前的
                    优先级在redis.conf中默认：replica-priority 100，值越小优先级越高；
                选择偏移量最大的
                    偏移量是指获得原主机数据最全；
                选择runid最小的
                    每个redis实例启动后都会随机生成一个40位的runid；
            注：选举出了新的主机，原主机就会变成新主机的从机；
        复制延迟
            所有写操作都先在主机上操作，同步到从机的过程中有一定的延迟；



