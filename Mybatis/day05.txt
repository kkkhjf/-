1、缓存机制
	Mybatis默认定义了两级缓存
		一级缓存
			默认情况下只有一级缓存（sqlSession级的缓存，也成为本地缓存）；
			与数据库同一次会话期间查询到的数据会放在本地缓存中，以后如果要获取相同的数据直接从缓存中拿，没必要再去查询数据库（返回的都是同一个对象）；
			一级缓存失败的情况
				sqlSession改变，一级缓存就会失效（一级缓存是sqlSession级别）；
				sqlSession相同，查询条件不同；
				sqlSession相同，两次查询之间执行了增删改操作；
				sqlSession相同，手动清除一级缓存（sqlSession.clearCache()）；
			注：一级缓存是将查询结果放进一个map中，每次执行查询语句时会在map中查看有没有有没有对应的结果，没有再执行查询语句；
		二级缓存
			需要手动开启和配置，基于namespace级的缓存（全局缓存）；
			工作机制
				一个会话，查询一条数据，这个数据就会被放在当前会话的一级缓存中；
				如果会话关闭，一级缓存中的数据就会被保存到二级缓存中，新的会话就可以参照二级缓存；
				不同namespace查出的数据会放在自己对应的map（缓存）中；
			二级缓存使用
				开启二级缓存
					在全局配置文件中，使用<setting name="cacheEnabled" value="true"/>开启二级缓存；
				去映射文件中配置使用二级缓存
					<cache/>标签
						属性
							eviction：缓存的回收策略
								LRU：最近最少使用，移除最长时间不使用的对象；
								FIFO：先进先出；
								SOFT：软引用，基于垃圾回收器状态和软引用规则的对象；
								WEAK：弱引用，基于垃圾回收器状态和弱引用规则的对象；
								默认的是LRU；
							flushOnterval：缓存刷新间隔
								缓存多长时间清空一次，默认不清空，设置一个毫秒值；
							readOnly：缓存是否只读，默认false
								true：只读，mybatis认为所有从缓存中获取数据的操作都是只读操作，不会修改数据，直接将数据在缓存中的引用交给用户，不安全，速度快；
								false：非只读，mybatis会利用反序列化&反序列的技术克隆一份新的数据给你，安全，速度慢；
							size：缓存存放多少个元素；
							type：指定自定义混村的全类名，实现Cache接口即可；
				我们的POJO需要实现序列化接口（Serializable）；
				注：查出的数据都会先默认放在一级缓存中，只有会话提交或者关闭后才会转移到二级缓存；
			缓存有关的设置和属性
				cacheEnable
					true：打开二级缓存；
					false：关闭二级缓存，一级缓存可以一直使用；
				每个select 标签都有useCache属性
					true：使用缓存；
					false：不使用缓存（一级缓存一直使用，二级不使用）；
				增删改标签都有flushCache属性
					true：清除缓存，一级二级都会清除(默认)；
					false：不清除缓存；
					注：查询标签也有该属性，默认是false；
				sqlSession.clearCache()
					只是清除当前Session的一级缓存；
				localCacheScope：本地缓存作用域
		引用其他命名空间的缓存
			使用<cache-ref namespace="命名空间名称"/>即可在本映射文件中使用另一个命名控件的缓存；
			