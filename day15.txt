1、线程的调度
		MAX_PRIORITY: 10
		MIN_PRIORITY:  1
		NORM_PRIORITY: 5//线程一般的优先级为5，最大为10，最小为1；		
		获取和设置当前线程优先级：
				setPriority()//设置当前线程优先级
				getPriority()//获取当前线程优先级
				注：高优先级的线程抢占低优先级的cpu执行权，高优先级高概率被执行，但不意味着高优先级执行完后才开始执行低优先级线程。
		
2、创建多线程（方式二）
		创建一个实现了Runnable接口的类；
		实现类去实现Runnable中的抽象方法：run（）；
		创建实现类的对象；
		将此对象作为参数传递到Thread类的构造器中，创建Thread类的对象；
		通过Thread类的对象调用start（）【启动线程、调用当前线程的run（）--->调用了Runnable类型的target的run（）方法】。

		比较创建线程的两种方式：
				开发中优先选择实现Runnable接口的方式；
				原因：实现的方式没有类继承的局限性；
				           实现的方式更适合来处理多个线程有共享数据的情况（如果创建一个实现Runnable类的对象，便可以实现数据共享）
				联系：两种方式都有需要重写的run（）方法。

3、线程的生命周期
		线程的生命周期（新建、就绪、运行、阻塞和死亡）
				运行----------------------------------------------------------------->阻塞的操作-------------------------------------------------------------------------------->运行		
				        （sleep（）、join（）、等待同步锁、wait（）和suspend（） ）	                 (sleep（）时间到、join（）结束、获取同步锁、notify（）notifyall（）resume（）)

4、线程的同步
    多个线程执行共享的数据时可能会出现数据的安全问题；
		当一个线程在操作共享数据时，其他线程不能参与进来，直到当前线程操作完后（即便遇到当前线程遇到阻塞），其他线程才能开始操作共享数据。
		Java同步机制的实现：
				方式一（同步代码块）
						synchronized（同步监视器）{
							
							//需要被同步的代码
						}
						说明：操作共享数据的代码，即为需要被同步的代码 ---> 包括的代码不能多也不能少；
						           同步监视器：俗称锁，任何一个类的对象都可以称当锁（多个线程必须要共用同一把锁 ）；
						           用实现Runnable接口实现同步机制可以考虑使用this作为锁，用继承Thread类实现同步机制可以考虑使用当前类当作锁（涉及反射知识）。
				方式二（同步方法）
						将需要被同步的代码放在一个方法里，在方法名前加上synchronized修饰
						实现Runnable接口完成同步机制同步方法中的锁默认为this，继承Thread实现同步机制同步方法前还要加上static，默认锁为当前类。 
            synchronized 修饰方法使用锁是当前this锁，synchronized 修饰静态方法使用锁是当前类的字节码文件。
		同步机制的优点：解决了线程的安全问题
			       缺点：操作同步代码时，只能有一个线程参与，其他线程等待，相当于是一个单线程的过程，效率低。

5、线程的死锁问题
     不同的线程分别占用对方需要的同步资源不放弃，都在等对方放弃自己需要的同步资源，这就是死锁。
     说明：出现死锁后不会出现异常，不会出现提示，只是所有的线程都处于阻塞状态，无法继续；
           我们使用同步时，要避免出现死锁。

6、使用Lock实现同步问题
    步骤：
        实例化ReentrantLock类（ReentrantLock look = new ReentrantLock(); ）；
        将需要被同步的代码放在try中，并在try中调用lock()（lock.lock();）；
        在finally里调用解锁方法unlock()（lock.unlock();）。
    synchronized和lock的异同：
        相同：二者都可以解决线程安全问题；
        不同：synchronized在执行完需要被同步的代码后可以自动的释放同步监视器；lock需要手动的启动和关闭。
        注：使用继承方式实现同步记得要将锁设置为静态。

7、线程的通信
     wait()：一旦执行此方法，当前线程就进入阻塞状态，并释放同步监视器；
     notify()：一旦执行下去，就会唤醒被wait的线程，如果有多个线程被wait就会唤醒优先级高的那个；
     notifyall()：会唤醒所有被wait的线程。
     
     注：wait()、notify()、notifyall()三个方法必须使用在同步代码块或同步方法中。；
         这三个方法的调用者必须是同步代码块或同步方法中的同步监视器，否则会出现UllegalMonitorStateException异常；
         这三个方法是定义在Object类中 。
   sleep（）和wait（）异同：
       相同点：一旦执行方法，都可以使得当前线程进入阻塞状态；
       不同点：两个方法声明的位置不同：Thread类中声明sleep（），Object类中声明wait（）；
              调用的要求不同（sleep()可以在任何需要的场景下调用，wait方法必须在同步代码块或同步方法中调用）；
              关于是否释放同步监视器：如果两个方法都使用在同步代码块或同步方法中，sleep（）不会释放锁，wait（）会释放锁。
